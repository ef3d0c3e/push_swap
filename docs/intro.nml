@html.page_title = Introduction to push_swap
@html.css = ./style.css

#+TABLE_OF_CONTENT Index

@@style.section = {
	"link_pos": "None",
	"link": ["a", "b", "c"]
}

@tex.main.fontsize = 9
@tex.main.preamble = \usepackage{xcolor, tikz, pgfplots} \\
\usepgfplotslibrary{patchplots} \\
\definecolor{__color1}{HTML}{d5d5d5} \\
\everymath{\color{__color1}\displaystyle}
@tex.main.block_prepend = \color{__color1}

@<main
function gen_values(id, length, stack)
	local colors = { "#2D2D2D", "#1E1E1E" }
	local graph = ""

	-- Values
	for i = 2, length do
		if i <= #stack then
			graph = graph
				.. string.format([[<TR><TD PORT="%d.%d" BGCOLOR="%s" HEIGHT="25" WIDTH="28">%s</TD></TR>]], id, i - 1, colors[1 + i % 2], stack[i])
		else
			graph = graph
				.. string.format([[<TR><TD PORT="%d.%d" HEIGHT="25" BORDER="0" WIDTH="28">&nbsp;</TD></TR>]], id, i - 1)
		end
	end

	return graph
end

function gen_stack(id, length, stack)
	local graph = string.format([[ stack_%d [label=< ]], id)

	-- Stack label
	graph = graph
		.. [[ <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4"> ]]
		.. string.format([[ <TR><TD PORT="title.%d" HEIGHT="25" BORDER="0"><FONT POINT-SIZE="14">%s</FONT></TD></TR> ]], id, stack[1])

	 -- Values
	graph = graph .. gen_values(id, length, stack)

	graph = graph
		.. [[ </TABLE> >] ]]
	return graph
end

function gen_stacks(stacks)
	local graph = [[
		digraph ComputerStack {
			bgcolor=transparent
			node [shape=none, fontcolor=white] ]]

	-- Find longest stack
	local longest = 0
	for k, stack in pairs(stacks) do
		if longest < #stack then
			longest = #stack
		end
	end
	
	local graph_rank = [[{rank=same;]]
	for k, stack in pairs(stacks) do
		graph = graph .. gen_stack(k, longest, stack)


		graph_rank = graph_rank
			.. string.format(" stack_%s", k)
	end

	graph = graph
		.. graph_rank .. "}}"
	return graph
end

function g_stack(stacks)
	nml.graphviz.push("dot", "100%", gen_stacks(stacks))
end

function g_stacks(label, first, second)
	local graph = [[
		digraph ComputerStacks {
			bgcolor=transparent
			node [shape=none, fontcolor=white]
			]]

	-- Find longest stack
	local longest = 0
	for k, stack in pairs(first) do
		if longest < #stack then
			longest = #stack
		end
	end
	for k, stack in pairs(second) do
		if longest < #stack then
			longest = #stack
		end
	end

	local id = 1;
	local rank = [[{rank=same;]]

	-- Left cluster
	graph = graph .. [[ subgraph cluster_left { label="" ]]
	for k, stack in pairs(first) do
		graph = graph .. gen_stack(id, longest, stack)
		rank = rank
			.. string.format(" stack_%s", id)
		id = id + 1
	end
	graph = graph .. [[ } ]]

	local first_right = id

	-- Right cluster
	graph = graph .. [[ subgraph cluster_right { label="" ]]
	for k, stack in pairs(second) do
		graph = graph .. gen_stack(id, longest, stack)
		rank = rank
			.. string.format(" stack_%s", id)
		id = id + 1
	end
	graph = graph .. [[ } ]]

	graph = graph
		.. string.format([[ stack_%d -> stack_%d [color=gray, label="%s", fontcolor=white, penwidth=2, ltail=cluster_left_inner, lhead=cluster_right_inner, labelloc=b]; ]], first_right - 1, first_right, label)

		.. rank .. "}"
		.. "}"
	
	nml.graphviz.push("dot", "100%", graph)
end
>@

# Introduction

*push_swap* is a sorting problem, using a state machine. The state machine requires two 'stacks' to operate and accepts a limited sets of instructions. To get the maximal ranking for this project, you must sort 500 random integers under 4500 instructions. As it stands out, $500 * \log_2{500} \approx 4482$ therefore push_swap will most likely require a `O(n \* log n)` solution.

# The stacks

The original problem mentions the use of two stacks. While they can be represented as stacks, the instructions lets us manipulate them as if they were 'circular'.
In fact the rotate and reverse rotate operation lets us access the bottom of the stack easily.
You find that to push a value to B's bottom translates to `pb rb`.
Which in traditional stack problems would require `O(n)` operations.

If you decide to implement the stacks as contiguous arrays, you'll find that
some operations become very expensive. For instance, every rotate operation
will require you to ``C, memmove(&stack[1], &stack[0], size-1)`` your stack,
in order to move all elements 1 up to make space for the bottom element.

With this information in mind, there are quite a number of data structures that would work for this problem. One could use a circular-doubly-linked-list, they would most certainly work, but be extra painful to deal with later. I found that a double-ended-queue (deque for short) would be more suited for this task. Since adding/removing at their fronts/backs can be implemented very efficiently.
There's a slight twist to this problem, as we already know the maximum size required for our 'stacks'.

Therefore, I've implemented my deque using a constant buffer of size $3 \times N$, where $N$ is the input size. The actual usable buffer is the $ [N,\, 2\times N]$ window. This window has free space it can move inside of. A rotate moves the window 1 down, while a reverse rotate moves it 1 up. When the window has no more space to move into, it is ``C, memcpy``ed to it's original position.

As the buffer has size $3 \times N$, the expensive ``C, memcpy`` happens once every $N$ rotates or reverse-rotates. Which amortizes it's cost, rendering the add/remove to front/back operations `O(1)`.

# Instruction set

Here are the instructions for our state machine:

#+LAYOUT_BEGIN Split
#+LAYOUT_BEGIN Centered
**pa**
#+LAYOUT_END
Takes the top element of A and push it to B:
%< g_stacks("pa", { {"A", 1, 2, 3}, {"B", "", "", ""} }, { {"A", 2, 3, ""}, {"B", 1, "", ""} })>%

#+LAYOUT_NEXT

#+LAYOUT_BEGIN Centered
**pb**

Takes the top element of B and push it to A:
#+LAYOUT_END
%< g_stacks("pb", { {"A", "2", "", "" }, {"B", 1, 3, ""} }, { {"A", 1, 2, ""}, {"B", 3, "", ""} })>%
#+LAYOUT_END

#+LAYOUT_BEGIN Split
#+LAYOUT_BEGIN Centered
**sa**

Swap A's top two elements:
#+LAYOUT_END
%< g_stacks("sa", { {" "}, {"A", 1, 2, 3} }, { {"A", 2, 1, 3}, {" "}, })>%

#+LAYOUT_NEXT

#+LAYOUT_BEGIN Centered
**sb**

Swap B's top two elements:
#+LAYOUT_END
%< g_stacks("sb", { {" "}, {"B", 1, 3, ""} }, { {"B", 3, 1, ""}, {" "}, })>%
#+LAYOUT_END

#+LAYOUT_BEGIN Split
#+LAYOUT_BEGIN Centered
**ss**

Performs **sa** and **sb**:
#+LAYOUT_END
%< g_stacks("ss", { {"A", "2", "4", "", ""}, {"B", 1, 3, "", ""} }, { {"A", 4, "2", "", ""}, {"B", 3, 1, "", ""} })>%

#+LAYOUT_NEXT

#+LAYOUT_BEGIN Centered
**ra**

Rotates A topwise:
#+LAYOUT_END
%< g_stacks("ra", { {" "}, {"A", "1", "2", "3" } }, { {"A", "2", "3", "1"}, {" "}, })>%
#+LAYOUT_END

#+LAYOUT_BEGIN Split
#+LAYOUT_BEGIN Centered
**rb**

Rotates B topwise:
#+LAYOUT_END
%< g_stacks("rb", { {" "}, {"B", "2", "1", "" } }, { {"B", "1", "2", ""}, {" "}, })>%

#+LAYOUT_NEXT

#+LAYOUT_BEGIN Centered
**rr**

Performs **ra** and **rb**:
#+LAYOUT_END
%< g_stacks("rr", { {"A", "2", "4", "5", "", ""}, {"B", 1, 3, "", "", ""} }, { {"A", 4, "5", 2, "", ""}, {"B", 3, 1, "", "", ""} })>%
#+LAYOUT_END

#+LAYOUT_BEGIN Split
#+LAYOUT_BEGIN Centered
**rra**

Rotates A bottomwise:
#+LAYOUT_END
%< g_stacks("rra", { {" "}, {"A", "2", "1", "3" } }, { {"A", "3", "2", "1"}, {" "} })>%

#+LAYOUT_NEXT

#+LAYOUT_BEGIN Centered
**rrb**

Rotates B bottomwise:
#+LAYOUT_END
%< g_stacks("rrb", { {" "}, {"B", "1", "3", "2"} }, { {"B", 2, 1, 3}, {" "} })>%
#+LAYOUT_END

#+LAYOUT_BEGIN Split
#+LAYOUT_BEGIN Centered
**rrr**

Performs **rra** and **rrb**:
#+LAYOUT_END
%< g_stacks("rrr", { {"A", "2", "4", "5", "", ""}, {"B", 1, 3, "", "", ""} }, { {"A", 5, "2", 4, "", ""}, {"B", 3, 1, "", "", ""} })>%

#+LAYOUT_NEXT

#+LAYOUT_END

## Simulation

In order to simulate outgoing instructions (when sorting) and incoming instructions (when running the checker), I encoded the instructions in a simple format:
#+LAYOUT_BEGIN Centered
``C, |3bits operator selector|2bits stack selector|``
#+LAYOUT_END

For the stack selector:
 * ``C, 01`` means stack `A`
 * ``C, 10`` means stack `B`
 * ``C, 11`` means both stacks

For the operator selector:
 * ``C, 001`` means swap
 * ``C, 010`` means push
 * ``C, 011`` means rotate
 * ``C, 100`` means reverse-rotate

Therefore, operation `pb` is encoded in the following way: ``C, (0b101 << 2) | 0b10``, ``C, 0b101`` represents the push operator, and ``C, 0b10`` represents stack `B`.

# Algorithm

:: TODO: REF
The basis of the algorithm is a 3-location stack-based quick sort.

## Small sorting

I handle base case sorting for all blocks with ``C, size <= 3``. I have manually built tables to sort from any block to A's top.

For ``C, size == 3``, that makes $3! = 4$ cases, for each possible destination (top A, bot B, etc..).
So in total 24 cases for size 3. Then 8 for size 2, and 1 for size 1.

#+LAYOUT_BEGIN[title=This is the code that dispatch sorting instructions\, according to every possible scenario (only for B's top and A's bot)] Spoiler
```C, Sample sorting table for size == 3
	else if (blk->dest == BLK_B_TOP)
		((void)(
		   (u > v && v > w && (op(s, STACK_OP_PA), op(s, STACK_OP_PA), op(s, STACK_OP_PA), 1))
		|| (u > w && w > v && (op(s, STACK_OP_PA), op(s, STACK_OP_SB), op(s, STACK_OP_PA), op(s, STACK_OP_PA), 1))
		|| (v > u && u > w && (op(s, STACK_OP_SB), op(s, STACK_OP_PA), op(s, STACK_OP_PA), op(s, STACK_OP_PA), 1))
		|| (v > w && w > u && (op(s, STACK_OP_SB), op(s, STACK_OP_PA), op(s, STACK_OP_SB), op(s, STACK_OP_PA), op(s, STACK_OP_PA), 1))
		|| (w > u && u > v && (op(s, STACK_OP_PA), op(s, STACK_OP_SB), op(s, STACK_OP_PA), op(s, STACK_OP_SA), op(s, STACK_OP_PA), 1))
		|| (w > v && v > u && (op(s, STACK_OP_SB), op(s, STACK_OP_PA), op(s, STACK_OP_SB), op(s, STACK_OP_PA), op(s, STACK_OP_SA), op(s, STACK_OP_PA), 1))
	));
	else if (blk->dest == BLK_A_BOT)
		((void)(
		   (u > v && v > w && (op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), 1))
		|| (u > w && w > v && (op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), op(s, STACK_OP_SA), 1))
		|| (v > u && u > w && (op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), op(s, STACK_OP_SA), op(s, STACK_OP_RRA), 1))
		|| (v > w && w > u && (op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), op(s, STACK_OP_SA), op(s, STACK_OP_RRA), op(s, STACK_OP_SA), 1))
		|| (w > u && u > v && (op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), op(s, STACK_OP_PB), op(s, STACK_OP_RRA), op(s, STACK_OP_SA), op(s, STACK_OP_PA), 1))
		|| (w > v && v > u && (op(s, STACK_OP_RRA), op(s, STACK_OP_PB), op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), op(s, STACK_OP_SA), op(s, STACK_OP_PA), 1))
	));```
#+LAYOUT_END

Another possible way to handle the 3-sort is to use the 2-sort function (which is way shorter). Then handle the special cases where the 2-sort function would not be enough.
However there would be cases where this would generate more instructions, so I opted for the table method. Needless to say, I had to double-check, then triple-check that the values inside tables are correct.

# Utility

## Moving values

Push_swap required me to move values from one place to another. I found that writing a ``C,blk_move`` function that does it is very handy.

Here's the table that tells us what moves are required to move values (row: *move from*, columns: *move to*):
|:talign=center: |  ``TOP A``  |  ``BOT A``  | ``TOP B``  |  ``BOT B``  |
| ``TOP A``      |             |**    ra   **|**  pb    **|** pb   rb **|
| ``BOT A``      |**  rra    **|**         **|**rra  pb **|**rra pb rb**|
| ``TOP B``      |** pa      **|** pa   ra **|**        **|**   rb    **|
| ``BOT B``      |** rrb  pa **|**rrb pa ra**|** rrb    **|**         **|

Using this table, I implement the following move function that moves from any location to any other location:

```C, Move function
void	blk_move(t_state *s, enum e_blk_dest from, enum e_blk_dest to)
{
	const uint8_t	id = (from << 2) | to;

	/* Check if move is legal */
	if (((from & __BLK_SEL) == __BLK_A && !s->sa.size)
		|| ((from & __BLK_SEL) == __BLK_B && !s->sb.size))
		return ;
	/* Move table */
	(void)((!(id % 5))
		|| (id == 1 && (op(s, STACK_OP_RA), 1))
		|| (id == 2 && (op(s, STACK_OP_PB), 1))
		|| (id == 3 && (op(s, STACK_OP_PB), op(s, STACK_OP_RB), 1))
		|| (id == 4 && (op(s, STACK_OP_RRA), 1))
		|| (id == 6 && (op(s, STACK_OP_RRA), op(s, STACK_OP_PB), 1))
		|| (id == 7 && (op(s, STACK_OP_RRA), op(s, STACK_OP_PB),
			op(s, STACK_OP_RB), 1))
		|| (id == 8 && (op(s, STACK_OP_PA), 1))
		|| (id == 9 && (op(s, STACK_OP_PA), op(s, STACK_OP_RA), 1))
		|| (id == 11 && (op(s, STACK_OP_RB), 1))
		|| (id == 12 && (op(s, STACK_OP_RRB), op(s, STACK_OP_PA), 1))
		|| (id == 13 && (op(s, STACK_OP_RRB), op(s, STACK_OP_PA),
			op(s, STACK_OP_RA), 1))
		|| (id == 14 && (op(s, STACK_OP_RRB), 1)));
}
```

# Optimizations

I will discuss all optimizations I have used in this section.

##{opti_state} Instructions

The following is a general optimization technique that works on almost all state-machine problems.
Essentially it may happen that a substring of instructions produces the same output as another (smaller) substring of instructions.
For instance:
 * `ra rb` produces the same side-effect as `rr`.
 * `ra rra` produces the same side-effect as `nop`.
By finding and replacing those substrings, we can lower the instruction count.
However, it's a bit more complicated than that.


Find all instructions substring that can be reduced.

Essentially that would be implemented using a large table, a function would iterate over the instructions and check if a table's substring matches currently.
The downside of this method is that it requires building a large table with all substrings that the function should replace. But once you have the table, most is already done.

However, that doesn't solve the issue entirely.
Consider the following:

Your table contains these mappings: `ra rb → rr` and `rb ra → rr`.
If the program contains the following substring: `ra ra rb rb`,
which can be reduced to `rr rr`, it will only be reduced to `ra rr rb`,
because the table has not enough information. If you go with this method,
be sure to properly populate your table for the best results.
In fact there are $^6P_3 = 20$ combinations for 3 `ra`'s and 3 `rb`'s.
Those could be generated and hard coded into the table.
But I'd rather have a general method that doesn't require
a lot of preliminary work.


### Side-effects

Each instruction will produce it's own side effects. The side effects depends on the instruction, but also on the state of the stacks.
It is important to understand side-effects as they are useful for optimization.

:: TODO

Sometime it may be safe to reorder instructions, as their side effect can be contained:
Suppose that the following program is valid:
#+LAYOUT_BEGIN Centered
``Plain Text, sb ra sa``
#+LAYOUT_END

Because `sb` is the only instruction in the program that acts on B. It is safe to reorder it's execution within the program.
Therefore the program can be simplified to the following:
#+LAYOUT_BEGIN Centered
``Plain Text, ra ss``
#+LAYOUT_END

### Qantitizing side-effects

Let's say I have an initial program state `state1` (instructions and stacks). I run the algorithm and end up N instructions later at `state2`.
From those two states, I'd like to be able to reconstruct the string of instructions that is required to reach `state2` from `state1`. Eventually this functions could be tuned to never generate more instructions than what was primarly used to obtain `state2` from `state1`. However, we'd be lucky to find such a function. Because I could just ask it to find the path from original state to the answer directly. However we can get pretty close to it, thanks to one technique: **backtracking bruteforce**.

I'll try to write down the problem so you can see it better.
When we run the sorting program and looks at the generated instructions.
I call $F_n = (A_n, B_n)$, the state of the program after executing $n$ instruction.
When $F_n$ is combined with the n-th instruction, $OP_n$, we obtain the next state: $F_n \circ OP_n = F_{n + 1}$.
This operation is repeated until the program is out of instructions, after which it halts.

From having already found a push_swap solution, we can construct $M = m_1 \circ \cdots \circ m_k$ such that $F_n \circ M = F_{n+k}$.
It would be nice to have the tools to analyze M in order to determine what changes are required to go from $F_n$ to $F_{n+k}$.

Our goal is, given two states: $F_n$ and $F_{n + k}$, find $S = s_1 \circ \cdots \circ s_p$ such that:
 - $F_n  \circ S = F_{n+k}$ meaning that $S$ is a path that goes from $F_n$ to $F_{n + k}$
 - $p < k$ meaning that the path $S$ is smaller than the original path $M$

#+LAYOUT_BEGIN Centered
Constructing the ``C, distance(state1, state2)`` function.
#+LAYOUT_END

:: PROB TREE GRAPH

## Optimizing quicksort
