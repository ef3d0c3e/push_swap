@html.page_title = Introduction to push_swap
@html.css = ./style.css

#+TABLE_OF_CONTENT Index

@@style.section = {
	"link_pos": "None",
	"link": ["a", "b", "c"]
}

@tex.main.fontsize = 9
@tex.main.preamble = \usepackage{xcolor, tikz, pgfplots} \\
\usepgfplotslibrary{patchplots} \\
\definecolor{__color1}{HTML}{d5d5d5} \\
\everymath{\color{__color1}\displaystyle}
@tex.main.block_prepend = \color{__color1}

@<main
function gen_values(id, length, stack)
	local colors = { "#2D2D2D", "#1E1E1E" }
	local graph = ""

	-- Values
	for i = 2, length do
		if i <= #stack then
			graph = graph
				.. string.format([[<TR><TD PORT="%d.%d" BGCOLOR="%s" HEIGHT="25" WIDTH="28">%s</TD></TR>]], id, i - 1, colors[1 + i % 2], stack[i])
		else
			graph = graph
				.. string.format([[<TR><TD PORT="%d.%d" HEIGHT="25" BORDER="0" WIDTH="28">&nbsp;</TD></TR>]], id, i - 1)
		end
	end

	return graph
end

function gen_stack(id, length, stack)
	local graph = string.format([[ stack_%d [label=< ]], id)

	-- Stack label
	graph = graph
		.. [[ <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4"> ]]
		.. string.format([[ <TR><TD PORT="title.%d" HEIGHT="25" BORDER="0"><FONT POINT-SIZE="14">%s</FONT></TD></TR> ]], id, stack[1])

	 -- Values
	graph = graph .. gen_values(id, length, stack)

	graph = graph
		.. [[ </TABLE> >] ]]
	return graph
end

function gen_stacks(stacks)
	local graph = [[
		digraph ComputerStack {
			bgcolor=transparent
			node [shape=none, fontcolor=white] ]]

	-- Find longest stack
	local longest = 0
	for k, stack in pairs(stacks) do
		if longest < #stack then
			longest = #stack
		end
	end
	
	local graph_rank = [[{rank=same;]]
	for k, stack in pairs(stacks) do
		graph = graph .. gen_stack(k, longest, stack)


		graph_rank = graph_rank
			.. string.format(" stack_%s", k)
	end

	graph = graph
		.. graph_rank .. "}}"
	return graph
end

function g_stack(stacks)
	nml.graphviz.push("dot", "100%", gen_stacks(stacks))
end

function g_stacks(label, first, second)
	local graph = [[
		digraph ComputerStacks {
			bgcolor=transparent
			node [shape=none, fontcolor=white]
			]]

	-- Find longest stack
	local longest = 0
	for k, stack in pairs(first) do
		if longest < #stack then
			longest = #stack
		end
	end
	for k, stack in pairs(second) do
		if longest < #stack then
			longest = #stack
		end
	end

	local id = 1;
	local rank = [[{rank=same;]]

	-- Left cluster
	graph = graph .. [[ subgraph cluster_left { label="" ]]
	for k, stack in pairs(first) do
		graph = graph .. gen_stack(id, longest, stack)
		rank = rank
			.. string.format(" stack_%s", id)
		id = id + 1
	end
	graph = graph .. [[ } ]]

	local first_right = id

	-- Right cluster
	graph = graph .. [[ subgraph cluster_right { label="" ]]
	for k, stack in pairs(second) do
		graph = graph .. gen_stack(id, longest, stack)
		rank = rank
			.. string.format(" stack_%s", id)
		id = id + 1
	end
	graph = graph .. [[ } ]]

	graph = graph
		.. string.format([[ stack_%d -> stack_%d [color=gray, label="%s", fontcolor=white, penwidth=2, ltail=cluster_left_inner, lhead=cluster_right_inner, labelloc=b]; ]], first_right - 1, first_right, label)

		.. rank .. "}"
		.. "}"
	
	nml.graphviz.push("dot", "100%", graph)
end
>@

# Introduction

*push_swap* is a sorting problem, using a state machine. The state machine requires two 'stacks' to operate and accepts a limited sets of instructions. To get the maximal ranking for this project, you must sort 500 random integers under 4500 instructions. As it stands out, $500 * \log_2{500} \approx 4482$ therefore push_swap will most likely require a `O(n \* log n)` solution.

# Data structure

The original problem mentions the use of two stacks. However they differ from traditional stacks problem, by having rotates operations.

If you try to do it with a stack, you'll find that some operations become expensive. For instance, every rotate operation will require
you to ``C, memmove(&stack[1], &stack[0], size-1)`` your stack, in order to
move all elements 1 up to make space for the bottom element.

With this information in mind, there are quite a number of data structures that would work for this problem. One could use a (doubly) linked-list, they would most certainly work, but be extra painful to deal with later. I found that a double-ended-queue (deque for short) would be more suited for this task. Since adding/removing at their fronts/backs can be implemented very efficiently.
There's a slight twist to this problem, as we already know the maximum size required for our 'stacks'.

Therefore, I've implemented my deque using a constant buffer of size $3 \times N$ where $N$ is the input size. The actual buffer that we use is the $ [N,\, 2\times N]$ window. This window has free space it can move inside of. A rotate moves the window 1 down, while a reverse rotate moves it 1 up. When the window has no more space to move into, it is ``C, memcpy``ed to it's original position.

As the buffer has size $3 \times N$, the expensive ``C, memcpy`` happens once every $N$ rotates or reverse-rotates. Which amortizes it's cost, rendering the add/remove to front/back operations `O(1)`.

# Instruction set

Here are the instructions for our state machine:

#+LAYOUT_BEGIN Split
#+LAYOUT_BEGIN Centered
**pa**
#+LAYOUT_END
Takes the top element of A and push it to B:
%< g_stacks("pa", { {"A", 1, 2, 3}, {"B", "", "", ""} }, { {"A", 2, 3, ""}, {"B", 1, "", ""} })>%

#+LAYOUT_NEXT

#+LAYOUT_BEGIN Centered
**pb**

Takes the top element of B and push it to A:
#+LAYOUT_END
%< g_stacks("pb", { {"A", "2", "", "" }, {"B", 1, 3, ""} }, { {"A", 1, 2, ""}, {"B", 3, "", ""} })>%
#+LAYOUT_END

#+LAYOUT_BEGIN Split
#+LAYOUT_BEGIN Centered
**sa**

Swap A's top two elements:
#+LAYOUT_END
%< g_stacks("sa", { {" "}, {"A", 1, 2, 3} }, { {"A", 2, 1, 3}, {" "}, })>%

#+LAYOUT_NEXT

#+LAYOUT_BEGIN Centered
**sb**

Swap B's top two elements:
#+LAYOUT_END
%< g_stacks("sb", { {" "}, {"B", 1, 3, ""} }, { {"B", 3, 1, ""}, {" "}, })>%
#+LAYOUT_END

#+LAYOUT_BEGIN Split
#+LAYOUT_BEGIN Centered
**ss**

Performs **sa** and **sb**:
#+LAYOUT_END
%< g_stacks("ss", { {"A", "2", "4", "", ""}, {"B", 1, 3, "", ""} }, { {"A", 4, "2", "", ""}, {"B", 3, 1, "", ""} })>%

#+LAYOUT_NEXT

#+LAYOUT_BEGIN Centered
**ra**

Rotates A topwise:
#+LAYOUT_END
%< g_stacks("ra", { {" "}, {"A", "1", "2", "3" } }, { {"A", "2", "3", "1"}, {" "}, })>%
#+LAYOUT_END

#+LAYOUT_BEGIN Split
#+LAYOUT_BEGIN Centered
**rb**

Rotates B topwise:
#+LAYOUT_END
%< g_stacks("rb", { {" "}, {"B", "2", "1", "" } }, { {"B", "1", "2", ""}, {" "}, })>%

#+LAYOUT_NEXT

#+LAYOUT_BEGIN Centered
**rr**

Performs **ra** and **rb**:
#+LAYOUT_END
%< g_stacks("rr", { {"A", "2", "4", "5", "", ""}, {"B", 1, 3, "", "", ""} }, { {"A", 4, "5", 2, "", ""}, {"B", 3, 1, "", "", ""} })>%
#+LAYOUT_END

#+LAYOUT_BEGIN Split
#+LAYOUT_BEGIN Centered
**rra**

Rotates A bottomwise:
#+LAYOUT_END
%< g_stacks("rra", { {" "}, {"A", "2", "1", "3" } }, { {"A", "3", "2", "1"}, {" "} })>%

#+LAYOUT_NEXT

#+LAYOUT_BEGIN Centered
**rrb**

Rotates B bottomwise:
#+LAYOUT_END
%< g_stacks("rrb", { {" "}, {"B", "1", "3", "2"} }, { {"B", 2, 1, 3}, {" "} })>%
#+LAYOUT_END

#+LAYOUT_BEGIN Split
#+LAYOUT_BEGIN Centered
**rrr**

Performs **rra** and **rrb**:
#+LAYOUT_END
%< g_stacks("rrr", { {"A", "2", "4", "5", "", ""}, {"B", 1, 3, "", "", ""} }, { {"A", 5, "2", 4, "", ""}, {"B", 3, 1, "", "", ""} })>%

#+LAYOUT_NEXT

#+LAYOUT_END

Technically, you'd want to use the `rr`, `ss` and `rrr` instructions where possible. However, there's a general optimization technique &{opti_state} that will do it for you, so you don't have to worry about using them in the first place.

# Algorithm

:: TODO: REF
The basis of the algorithm is a 3-location stack-based quick sort.

## Sorting

I handle base case sorting for all blocks with ``C, size <= 3``. I have manually built tables to sort from any block to A's top.

For ``C, size == 3``, that makes $3! = 4$ cases, for each possible destination (top A, bot B, etc..).
So in total 24 cases for size 3. Then 8 for size 2, and 1 for size 1.

Below is the code that dispatch the instructions according to every possible scenario (only for B's top and A's bot):
```C, Sample sorting table for size == 3
	else if (blk->dest == BLK_B_TOP)
		((void)(
		   (u > v && v > w && (op(s, STACK_OP_PA), op(s, STACK_OP_PA), op(s, STACK_OP_PA), 1))
		|| (u > w && w > v && (op(s, STACK_OP_PA), op(s, STACK_OP_SB), op(s, STACK_OP_PA), op(s, STACK_OP_PA), 1))
		|| (v > u && u > w && (op(s, STACK_OP_SB), op(s, STACK_OP_PA), op(s, STACK_OP_PA), op(s, STACK_OP_PA), 1))
		|| (v > w && w > u && (op(s, STACK_OP_SB), op(s, STACK_OP_PA), op(s, STACK_OP_SB), op(s, STACK_OP_PA), op(s, STACK_OP_PA), 1))
		|| (w > u && u > v && (op(s, STACK_OP_PA), op(s, STACK_OP_SB), op(s, STACK_OP_PA), op(s, STACK_OP_SA), op(s, STACK_OP_PA), 1))
		|| (w > v && v > u && (op(s, STACK_OP_SB), op(s, STACK_OP_PA), op(s, STACK_OP_SB), op(s, STACK_OP_PA), op(s, STACK_OP_SA), op(s, STACK_OP_PA), 1))
	));
	else if (blk->dest == BLK_A_BOT)
		((void)(
		   (u > v && v > w && (op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), 1))
		|| (u > w && w > v && (op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), op(s, STACK_OP_SA), 1))
		|| (v > u && u > w && (op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), op(s, STACK_OP_SA), op(s, STACK_OP_RRA), 1))
		|| (v > w && w > u && (op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), op(s, STACK_OP_SA), op(s, STACK_OP_RRA), op(s, STACK_OP_SA), 1))
		|| (w > u && u > v && (op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), op(s, STACK_OP_PB), op(s, STACK_OP_RRA), op(s, STACK_OP_SA), op(s, STACK_OP_PA), 1))
		|| (w > v && v > u && (op(s, STACK_OP_RRA), op(s, STACK_OP_PB), op(s, STACK_OP_RRA), op(s, STACK_OP_RRA), op(s, STACK_OP_SA), op(s, STACK_OP_PA), 1))
	));```

# Utility

## Moving values

Push_swap required me to move values from one place to another. I found that writing a ``C,blk_move`` function that does it is very handy.

Here's the table that tells us what moves are required to move values (row: *move from*, columns: *move to*):
|:talign=center: |  ``TOP A``  |  ``BOT A``  | ``TOP B``  |  ``BOT B``  |
| ``TOP A``      |             |**    ra   **|**  pb    **|** pb   rb **|
| ``BOT A``      |**  rra    **|**         **|**rra  pb **|**rra pb rb**|
| ``TOP B``      |** pa      **|** pa   ra **|**        **|**   rb    **|
| ``BOT B``      |** rrb  pa **|**rrb pa ra**|** rrb    **|**         **|

Using this table, I implement the following move function that moves from any location to any other location:

```C, Move function
void	blk_move(t_state *s, enum e_blk_dest from, enum e_blk_dest to)
{
	const uint8_t	id = (from << 2) | to;

	/* Check if move is legal */
	if (((from & __BLK_SEL) == __BLK_A && !s->sa.size)
		|| ((from & __BLK_SEL) == __BLK_B && !s->sb.size))
		return ;
	/* Move table */
	(void)((!(id % 5))
		|| (id == 1 && (op(s, STACK_OP_RA), 1))
		|| (id == 2 && (op(s, STACK_OP_PB), 1))
		|| (id == 3 && (op(s, STACK_OP_PB), op(s, STACK_OP_RB), 1))
		|| (id == 4 && (op(s, STACK_OP_RRA), 1))
		|| (id == 6 && (op(s, STACK_OP_RRA), op(s, STACK_OP_PB), 1))
		|| (id == 7 && (op(s, STACK_OP_RRA), op(s, STACK_OP_PB),
			op(s, STACK_OP_RB), 1))
		|| (id == 8 && (op(s, STACK_OP_PA), 1))
		|| (id == 9 && (op(s, STACK_OP_PA), op(s, STACK_OP_RA), 1))
		|| (id == 11 && (op(s, STACK_OP_RB), 1))
		|| (id == 12 && (op(s, STACK_OP_RRB), op(s, STACK_OP_PA), 1))
		|| (id == 13 && (op(s, STACK_OP_RRB), op(s, STACK_OP_PA),
			op(s, STACK_OP_RA), 1))
		|| (id == 14 && (op(s, STACK_OP_RRB), 1)));
}
```

# Optimizations

##{opti_state} State machine

This is a general optimization technique that works on almost all state-machine problems.
Essentially it may happen that a string of instructions produce the same output as another (smaller) set of instructions.
For instance:
 * `ra rb` produces the same side effect as `rr`.
 * `ra rra` produces the same side effect as `nop`.

### Side-effects

Each instruction will produce it's own side effects. The side effects depends on the instruction, but also on the state of the stacks.
:: TODO para

Sometime it may be safe to reorder instructions, as their side effect can be contained:
Suppose that the following program the following is valid:
``Plain Text
sb
ra
sa``
Because `sb` is the only instruction in the program that acts on B. It is safe to reorder it anywhere in the program.

Therefore the program can be simplified to the following:
``Plain Text
ra
ss``
